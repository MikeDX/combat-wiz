/*
; Combat for Atari by Larry Wagner
; Ported to WIZ by MikeDX - March 2023
;
; Original disassembly by Harry Dodgson
; Commented further by Nick Bensema (1997)
; Major overhaul by Roger Williams (2002) 
;
; My intent in overhauling this classic disassembly is to finish it
; so that the purpose of every instruction, memory location, and
; table is made completely clear.
;
; For some reason the NBCOMBAT file ORG statements all point to
; the region $1000-$1FFF; this would play in a VCS but the cartridge
; .BIN I have is mapped from $F000-$FFFF.  This file compiles with
; DASM to an image which differs from this ROM only in the few
; unwritten bytes between the end of data and the startup vectors.
; DASM sets these to zero, typical of unwritten RAM, but in the cart
; they are $FF, typical of unprogrammed PROM.
;
; Thanks to Brian Prescott for pointing me to Joe DeCuir's
; presentation notes, which revealed Atari's original names
; for the main loop toplevel routines and offered some guidance
; on their separation of function.
;
; I have removed some of the breathless intro-to-VCS and historical
; comments.  This version assumes a basic familiarity with VCS
; programming, and is meant as a basis for hacking the COMBAT game
; itself.  There are plenty of resources outside of this file if
; you don't know how the VCS works.
;
; For reference, as this is rather important when reading the,
; code, here is the game variation matrix (it is not trivially
; obvious how this corresponds to GAMVAR):
;
;                Game No.                Open Field
;                |  Straight Missiles    |  Easy Maze
;                |  |  Guided Missiles   |  |  Complex Maze
;                |  |  |  Machine Guns   |  |  |  Clouds
;                |  |  |  |  Direct Hit  |  |  |  |
;                |  |  |  |  |  Billiard |  |  |  |
;                |  |  |  |  |  |   Hit  |  |  |  |
;                |  |  |  |  |  |        |  |  |  |
;                |  |  |  |  |  |        |  |  |  |
;
;TANK            1  -  X  -  -  -        X  -  -  -
;                2  -  X  -  -  -        -  X  -  -
;                3  X  -  -  -  -        -  X  -  -
;                4  -  X  -  -  -        -  -  X  -
;                5  X  -  -  -  -        -  -  X  -
;--------------------------------------------------
;TANK-PONG       6  -  -  -  X  X        -  X  -  -
;                7  -  -  -  X  X        -  -  X  -
;                8  -  -  -  -  X        X  -  -  -
;                9  -  -  -  -  X        -  X  -  -
;--------------------------------------------------
;INVISIBLE TANK 10  -  X  -  -  -        X  -  -  -
;               11  -  X  -  -  -        -  X  -  -
;--------------------------------------------------
;INVISIBLE      12  -  -  -  X  X        -  X  -  -
;TANK-PONG      13  -  -  -  -  X        X  -  -  -
;               14  -  -  -  -  X        -  X  -  -
;--------------------------------------------------
;BI-PLANE       15  -  X  -  -  -        -  -  -  X
;               16  X  -  -  -  -        -  -  -  X
;               17  -  -  X  -  -        -  -  -  X
;               18  -  -  X  -  -        X  -  -  -
;     2 vs. 2   19  -  X  -  -  -        X  -  -  -
;     1 vs. 3   20  X  -  -  -  -        X  -  -  -
;--------------------------------------------------
;JET            21  -  X  -  -  -        -  -  -  X
;               22  X  -  -  -  -        -  -  -  X
;               23  -  X  -  -  -        X  -  -  -
;               24  X  -  -  -  -        X  -  -  -
;     2 vs. 2   25  -  X  -  -  -        -  -  -  X
;     1 vs. 3   26  -  X  -  -  -        X  -  -  -
;     2 vs. 2   27  X  -  -  -  -        X  -  -  -
*/

import "vcs";
import "banks";

import "vars";

import "gfx";


in rom @ ROMADDR {
  START:
  // Disable interrupts
  nointerrupt = true;  
  // Disable decimal mode
  decimal = false;       
  
  // set stack pointer to 0xFF (set this to a variable)
  s = x = 0xFF;
  
  // Clear memory from 0x00 to 0xAd (0x5d is an unsigned value for 0xA2)
  x = 0x5d;
  ClearMem();
  
  a = 0x10;
  SWBCNT = a;
  GameOn = a;
  ClrGam(); // clear game RAM $82-$A2

  while true {
    VCNTRL(); // Generate a VSYNC and begin VBLANK

    // VBLANK logic:
    GSGRCK(); // Parse console switches
    LDSTEL(); // Load Stella Registers
    CHKSW();  // Check Joystick Switches
    COLIS();  // Check Collision Registers
    STPMPL(); // Setup Player, Missile Motion
    ROT();    // Rotate Sprites
    SCROT();  // Calculate Score Offsets

    VOUT();   // do the Kernal (trashes the stack ptr,
              // but then restores it because it IS
              // used when we reiterate this loop)
  }
  
  /*
  ;
  ; ------------------------------------------------------------
  ;
  ; Vertical CoNTRoL
  ;
  ; Vertical sync, basic frame-start housekeeping
  ;
*/
  func VCNTRL() {
    CLOCK++;
    HMCLR = a;
    a = 2;
    WSYNC = a;
    VBLANK = a;
    WSYNC = a;
    WSYNC = a;
    WSYNC = a;
    VSYNC = a;
    WSYNC = a;
    WSYNC = a;
    a = 0;
    WSYNC = a;
    VSYNC = a;
    a = 0x43;
    TIM64T = a;
  }
  /*
  ;
  ; ------------------------------------------------------------
  ;
  ; Video OUT -- THE KERNAL
  ;
  ; We start with the score, then we render the playfield, players,
  ; and missiles simultaneously. All in all, an average day for a VCS.
  ;
*/
  func VOUT() {
    a = 0x20;
    ScanLine = a; // We're assuming scanline $20.
    WSYNC = a;
    HMOVE = a;    // Move sprites horizontally.
    do {
      a = INTIM;
    } while !zero;
    
    WSYNC = a;   
    CXCLR = a;   	// Clear collision latches
    VBLANK = a;  	// End vertical blank
    TMPSTK = x = s;  	// Save stack pointer
    CTRLPF = a = 0x02;  // Double, instead of reflect.
    x = KLskip;
    // Skip a few scanlines...
    do {
      WSYNC = a;
      x--;
    } while !zero;
    a = KLskip;
    cmp(a,0x0e);  // "No Score" value of KLskip
    goto Vmain if zero;
  /*
  ;
  ; KLskip is set as such so that when the score is
  ; to be displayed, it waits for just the right time
  ; to start drawing the score, but if the score is
  ; not to be displayed, as when the score flashes
  ; signifying "time's almost up", it waits for just
  ; the right time to start drawing the rest of the
  ; screen.
  ;
  ; Draw the score:
  ;
  */
    x = 0x05;	// Score is five bytes high.
    a = 0x00;	// Clear number graphics.
    NUMG0 = a;  // They won't be calculated yet,
    NUMG1 = a;  // but first time through the loop
                // the game will try to draw with
       		// them anyway.

    do { // VSCOR;
      WSYNC = a; 	// Start on new scanline
      a = NUMG0; 	// Take last scanline's left score,
      PF1 = a;	// and recycle it,
    
    /*
    ;
    ; Here, we begin drawing the next scanline's
    ; left score, as the electron beam moves towards
    ; the right score's position in this scanline.
    ;
    */
    
      y = SCROFF[2];
      a = NUMBERS[y];	// Get left digit.
      a = a & 0xf0;
      NUMG0 = a;
      y = SCROFF[0];
      a = NUMBERS[y];	// Get right digit.
      a = a & 0x0f;
      a = a | NUMG0;
      NUMG0 = a;	// Left score is ready to ship.
      a = NUMG1;	// Take last scanline's right score,
      PF1 = a;		// and recycle it.
      y = SCROFF[3];
      a = NUMBERS[y];	// Left digit...
      a = a & 0xf0;
      NUMG1 = a;
      y = SCROFF[1];
      a = NUMBERS[y];	// right digit...
      a = a & SHOWSCR;
      /*
      ;
      ; Now, we use our fresh, new score graphics in this next scanline.
      ;
      */
    
      WSYNC = a;	// *COUNT*
      a = a | NUMG1;	// Finish calculating     (0) +3
      NUMG1 = a;	// right score.           (3) +3
      a = NUMG0;	// 			  (6) +3
      PF1 = a;		//			  *9* +3    
      /*
      ;
      ; We use this time to check whether we're at the end of our loop.
      ;
      */
      x--;		//			  (12)+2
      break if negative;	// (14)+2 No Branch
      /*
      ;
      ; If so, we're out of here.  Don't worry, the score will be
      ; cleared immediately, so nobody will know that we've gone
      ; past five bytes and are displaying garbage.
      ;  
      */
      SCROFF[0]++;	// ; (16)+5
      SCROFF[2]++;	// Get ready to draw the next
      SCROFF[1]++;	// line of the byte.
      SCROFF[3]++;
      a = NUMG1;
      PF1 = a;		// Right score is in place.
    } while true;	// Go to next scanline,
    /*
    ; Main Kernal Display loop for the game itself
    ;*/
    
Vmain:
    a = 0;		// Inner Display Loop
    PF1 = a;		// Clear the score.
    WSYNC = a;
    a = 0x05;
    CTRLPF = a;		// Reflecting playfield.
    a = Color0;
    COLUP0 = a;		// How often must THIS be done?
    a = Color1;
    COLUP1 = a;
VField:
    x = 0x1e;		// Very Sneaky -
    s = x;		// Set stack to missile registers
    carry = true;
    
    /*
    ;  
    ; This yields which line of player 0 to draw.
    ;
    */
    
    a = TankY0;
    a = a -#ScanLine;		// A=TankY0-ScanLine
    a = a & 0xfe;		// Force an even number
    
    x = a;			// Only sixteen bytes of 
    a = a & 0xf0;		// sprite memory, so...

//    if !zero {
    goto VdoTank if zero;
    a = 0x00;			// blank the tank.
    //} 
  	
    goto VnoTank if zero;
//    if !zero {
      // doTank
VdoTank:
      a = HIRES[x];		// Else, load the appropriate byte.
//    }

VnoTank:
    WSYNC = a;			// ----END OF ONE LINE----
    GRP0 = a;			// Just for player 0.
    /*
    ;
    ; The infamous Combat Stack Trick:
    ;
    ; Keep in mind that at this point, the stack pointer
    ; is set to the missile registers, and the "zero-result"
    ; bit of the P register is the same at the bit ENAM0/1
    ; looks at.
    ;*/
    
    a = MissileY1;
    a = a ^ ScanLine;
    a = a & 0xFE;
    push(p); 		// This turns the missle 1 on/off

    a = MissileY0;
    a = a ^ ScanLine;
    a = a & 0xFE;
    push(p);		// This turns the missle 0 on/off
    /*
    ;
    ; We've got the missile taken care of.
    ; Now let's see which line of the playfield to draw.
    ;*/
    
    a = ScanLine;
    if negative {
      a = a ^ 0xF8;
    }
    cmp(a,0x20);
    
    if (carry) { 	// Branch if at bottom.
      a = a >>> 3;	// Divide by eight,
      y = a;		// and stow it in the Y-register.
    }
    /*
    ;
    ; By now, the electron beam is already at the next
    ; scanline, so we don't have to do a STA WSYNC.
    ;
    ; This yields which line of Tank 1 to draw.
    ;
    */
    a = TankY1;
    carry = true;
    a = a -#ScanLine;	// A=TankY1 - ScanLine
    ScanLine++;		// Increment the loop.
    nop();
    a = a | 0x01;	// Add bit 0, force odd number.
    x = a;
    
    a = a & 0xF0;	// There are only sixteen bytes of

    goto VdoT1 if zero;	// sprite memory, so...
//    if (!zero) {
    a = 0x00;		// If tank is not ready, blank it.
    
    
//    if (!zero) { 
    goto VnoT1 if zero;
/*    if (!zero) {
      a = 0x00;
      if (!zero) {
        a = HIRES[x];
      }
      bit(PF_PONG);

    }
 */  
    
VdoT1:
    a = HIRES[x];	// Else, draw the tank
VnoT1:
    bit(PF_PONG);
    GRP1 = a;
    goto VnoPF if negative;	// If PF_PONG bit 7 set, don't write PF
    a = (LORES as *u8)[y];	// (this means game variation has blank
    PF0 = a;			// background)
    a = (LORES2 as *u8)[y];
    PF1 = a;
    a = (LORES4 as *u8)[y];
    PF2 = a;
VnoPF:
    ScanLine++;			// One more up in the loop.
    a = ScanLine;
    a = a ^ 0xEC;
    goto VField if !zero;
    x = TMPSTK;			// Restore stack pointer, which is
    s = x;			// used for calls in main game loop
    ENAM0 = a;		// Clear a bunch of registers.
    ENAM1 = a;
    GRP0 = a;
    GRP1 = a;
    GRP0 = a;			// In case GRP0 isn't COMPLETELY zeroed.
    PF0 = a;
    PF1 = a;
    PF2 = a;
  }

  
  func GSGRCK() {
/*
; ------------------------------------------------------------
;
; Game Select Game Reset ChecK
;
; Executed immediately after VCNTRL, this subroutine parses all
; the console switches.
;
*/

    a = SWCHB;		// Start/Reset button....
    a = a >>> 1; 	// Shove bit 0 into carry flag,
    if (!carry) {	// and if it's pushed...
      /*
      ;
      ; Start a new game.
      ;
      */
      a = 0x0f;
      SHOWSCR = a;	// Show right score.
      a = 0xff;		// Set all bits
      GameOn = a;	// in GameOn. 
      a = 0x80;
      GameTimer = a;	// and bit 7 of GameTimer (this is not too
	               	// significant, as GameTimer rollover is
	                // only checked if GameOn<>$00)
      
      x = 0xe6;
      ClearMem();	// zero out $89 thru $A2
      goto ResetField if zero;	// Unconditional branch
    }
NoNewGM:
    y = 0x02;		// Assume score to be drawn
    a = GameTimer;	// If game in play (GameOn=$FF) AND
    a = a & GameOn;	// GameTimer < 7/8 finished @ $F0,
    cmp(a,0xf0);	// draw the score unconditionally.
    if(carry) {
      a = CLOCK;	// CLOCK used to flash score near end
      a = a & 0x30;	// of play, note the peripheral synchronization
      if(zero) {	// with GameTimer's timing of the game, which
        		// always ends when CLOCK & $3F = 0.  CLOCK
                        // is used here because the score blink
	                // off duty cycle is a too quick for
	                // GameTimer to handle, being about 1/3 sec.
        
        y = 0x0e;	// Set this for no score
      }
    }
SCdrawn:
  KLskip = y;		//  where the Kernal will find it
  a = CLOCK;
  a = a & 0x3f;		// CLOCK also used to slow debounce reset
  if (zero) {
    /*
    ;
    ; GameTimer is incremented and SelDbnce reset when
    ; CLOCK & $3F = 0.  This occurs 1 frame out of 64 or
    ; about once/second.  Thus the game is 128*64 frames
    ; or about 2 minutes long.
    ;
    */
    SelDbnce = a;	// Reset Select Debounce Flag.  This is
    			// what keeps incrementing the selection
    			// if you hold Select down for a long time.
    
    GameTimer++;	// increment the Main Game ~1-sec Timer.

    if (zero) {		// if GameTimer rolls over,
      GameOn = a;	// zero GameOn -- game over
    }
  }
    
ChkSel:
    a = SWCHB;		// Select button???
    a = a & 0x02;
    if (!zero) {
      SelDbnce = a;	// Set flag: Sel has not been down
//      return if !zero;
      goto CS_RTS if !zero;
    
      bit(SelDbnce);
      //return if negative;
    
      goto CS_RTS if negative;
    
      BINvar++;
    }
ClrGam:
    x = 0xdf;
ClrGRST:
    ClearMem();
    a = 0xff;
    SelDbnce = a;
    y = BINvar;
    a = VARMAP[y];
    GAMVAR = a;
    a = a ^ 0xff;
    if (zero) {
      x = 0xdd;
      goto ClrGRST if !zero;
    }
SelGO:
    a = BCDvar;
    decimal = true;
    carry = false;
    a = a +#1;
    BCDvar = a;
    SCORE = a;
    decimal = false;
    bit(GAMVAR);
    if (negative) {
      GAMSHP++;
    	if(overflow) {
          GAMSHP++;
        }
    }

/*
    
ChkSel  LDA  SWCHB              ; Select button???
	AND  #$02
	BEQ  SelDown
	STA  SelDbnce           ; Set flag: Sel has not been down
	BNE  CS_RTS             ; Unconditional branch
	;
SelDown BIT  SelDbnce           ; If Sel has been down,
	BMI  CS_RTS		; don't select a new game.
	;
	INC  BINvar             ; SELECT: Go to next game.
ClrGam  LDX  #$DF               ; Clear data from current game ($82-$A2)
ClrGRST JSR  ClearMem
	LDA  #$FF
	STA  SelDbnce           ; Set flag: Sel has been down.
	LDY  BINvar
	LDA  VARMAP,Y           ; Get feature bits for this variation.
	STA  GAMVAR
	EOR  #$FF               ; #$FF signifies end of variations
	BNE  SelGO              ; Not at end yet, set up new game
	LDX  #$DD		; Clear $80-$A2; resets BINvar, BCDvar
	BNE  ClrGRST            ; so we start over. BNE is unconditional.
	;
SelGO	LDA  BCDvar		; Since we have incremented BINvar, we
	SED                     ; must increment BCDvar in BCD to keep
	CLC                     ; it in sync. Note BCDvar is actually
	ADC  #1                 ; BinVar+1, since it's incremented when
	STA  BCDvar             ; we reset but don't increment BINvar.
	STA  SCORE              ; Display variation as score 0
	CLD
	BIT  GAMVAR             ; GAMSHP was reset at ClrGam...
	BPL  ResetField         ; if this is a plane game,
	INC  GAMSHP             ; increase GAMSHP.
	BVC  ResetField         ; if this is a jet game,
	INC  GAMSHP             ; increase GAMSHP further still.
	;
	; Branches here when game is started, too.
	;
        */
ResetField:
    /*
	JSR  InitPF
	;
	; Assuming plane game for now, we set the right player
	; at a slightly higher position than the left player,
	; and the position of the right player is irrelevant.
	;
	LDA  #50
	STA  TankY1
	LDA  #134
	STA  TankY0
	BIT  GAMVAR             ; Check to see if it is a tank game.
	BMI  CS_RTS             ; Nope, bail.
	                        ; It is a tank game, so
	STA  TankY1             ; Right tank has same Y value,
	STA  RESP1              ; and tank is at opposite side.
	LDA  #$08
	STA  DIRECTN+1          ; and right player faces left.
	LDA  #$20
	STA  HMP0
	STA  HMP1
	STA  WSYNC
	STA  HMOVE
CS_RTS	RTS  
*/
CS_RTS:
    
  }
  
  func LDSTEL() {
    
  }
  
  func CHKSW() {
    
  }

  func COLIS() {
    
  }
  
  func STPMPL() {
    
  }
  
  func ROT() {

  }
  
  func SCROT() {
    
  }
  
  
  func MLOOP() {
    
  }
//in rom @ 0xf19a {
  func ClrGam() {
    x = 0xdf;
    ClearMem();
    a = 0xff;
    SelDbnce = a;
    y = BINvar;
//    a = 
  }
}

in rom @ 0xf5bd {
  /*
  ;
  ; ------------------------------------------------------------
  ;
  ; Zero out zero-page memory starting with ($A3+X) MOD $100,
  ; through $A2 wrapping around at $100.
  ;
  ; Calling with:
  ; X=$5D will clear $00-$A2
  ; X=$DD will clear $80-$A2
  ; X=$DF will clear $82-$A2
  ; X=$E6 will clear $89-$A2
  ;
  ; Returns with zero bit set.
  ;
  */
  func ClearMem() {
    // clear memory from x to ram_A2;
    a = 0;
    do {
      x++;
      ram_A2[x] = a;
    } while !zero;
    
  }  
}

in rom @ 0xF700 {
  const VARMAP : [u8] = [
    0b00101000,
    0b00001000,
    0b00100000,
    0b00000000,
    0b01001000, // TANK PONG
    0b01000000,
    0b01011000,
    0b00100101, // INVISIBLE TANK
    0b00101001,
    0b01001001, // INVISBLE TANK-PONG
    0b01010101,
    0b01011001,
    0b10101000, // BIPLANE
    0xFF // END
    ];
  /*
VARMAP:
  .BYTE  $24 ;Game 1:  0010 0100  TANK
	.BYTE  $28 ;Game 2:  0010 1000
	.BYTE  $08 ;Game 3:  0000 1000
	.BYTE  $20 ;Game 4:  0010 0000
	.BYTE  $00 ;Game 5:  0000 0000
	.BYTE  $48 ;Game 6:  0100 1000  TANK PONG
	.BYTE  $40 ;Game 7:  0100 0000
	.BYTE  $54 ;Game 8:  0101 0100
	.BYTE  $58 ;Game 9:  0101 1000
	.BYTE  $25 ;Game 10: 0010 0101  INVISIBLE TANK
	.BYTE  $29 ;Game 11: 0010 1001
	.BYTE  $49 ;Game 12: 0100 1001  INVISIBLE TANK-PONG
	.BYTE  $55 ;Game 13: 0101 0101
	.BYTE  $59 ;Game 14: 0101 1001
	.BYTE  $A8 ;Game 15: 1010 1000  BIPLANE
	.BYTE  $88 ;Game 16: 1000 1000
	.BYTE  $98 ;Game 17: 1001 1000
	.BYTE  $90 ;Game 18: 1001 0000
	.BYTE  $A1 ;Game 19: 1010 0001
	.BYTE  $83 ;Game 20: 1000 0011
	.BYTE  $E8 ;Game 21: 1110 1000  JET FIGHTER
	.BYTE  $C8 ;Game 22: 1100 1000
	.BYTE  $E0 ;Game 23: 1110 0000
	.BYTE  $C0 ;Game 24: 1100 0000
	.BYTE  $E9 ;Game 25: 1110 1001
	.BYTE  $E2 ;Game 26: 1110 0010
	.BYTE  $C1 ;Game 27: 1100 0001
	;
	; $FF to signify end of game variations.
	;
	.BYTE  $FF
        */
}

// setup vectors
in rom @ 0xFFFA {
  const : [u16] = [(0x0 as u16), (&START as u16), 0x0];
}

